import urllib.request as request  
import json
import datetime      # current date-time-day
import time          # time.sleep(seconds)  delay execution

# Variable values
CSA_TIMETABLE_LINK = "https://my-json-server.typicode.com/Jagannathes/api-trial/TT"



# LHS don't vary
TIMETABLE_LINK = CSA_TIMETABLE_LINK


def getData(DATA_LINK):
    try :
        response = request.urlopen(DATA_LINK)
        response.getcode() == 200
        source = response.read()
        data = json.loads(source)
        return data

    except:
        print('An error occurred while attempting to retrieve data from the API.')
        raise Exception("Couldn't Retrive data from database! \n Aborting.")


def checkInRange(hour, minute, timerange):
   
    start_hour = timerange.split("-")[0].split(':')[0]
    start_minute = timerange.split("-")[0].split(':')[1]
    end_hour = timerange.split("-")[1].split(':')[0]
    end_minute = timerange.split("-")[1].split(':')[1]

    #check if in range
    #wont work if timrange is split across 2 days (00:00  will be a prob)
    if(hour < start_hour):
        return False
    elif(hour == start_hour):
        if(start_minute <= minute  and minute <= end_minute):
            return True
        else:
            return False
        if(minute <= end_minute):
            return True
        else:
            return False
    elif(hour < end_hour):
        return True
    elif(hour == end_hour):
        if(minute <= end_minute):
            return True
        else:
            return False
    else:
        return False


#Takes global hour, min and 
def getsubject_or_none(hour, minute, TT):

    Timings = TT[weekday].keys()  #Timings is a list of today's timetable timings

    for i in Timings:
        if(checkInRange(hour, minute, i)):
            subject = TT[weekday][i]
            return subject
        else:
            return None


#this function will only be called when we are not in the range of any subject
# so we only need to compare now-time to start time of the day or the next day
def nextclass(hour, minute, TT):
    #Return format
    nextcls = { "day" : "nil",
                "time" : "nil",
                "subject" : "nil"
                }


    Timings = TT[weekday].keys()  #Timings is a list of today's timetable timings
    for i in Timings:
        start_hour = i.split("-")[0].split(':')[0]
        start_minute = i.split("-")[0].split(':')[1]
        if(hour <= start_hour):
            nextcls["day"]     = weekday
            nextcls["time"]    = i
            nextcls["subject"] = TT[weekday][i]
            return nextcls

    # this loop will completely get over and not return anything when we are at the end of the day
    # so the next class will be next day first class
    temp = iter(TT)
    for key in temp:
        if key == weekday:
            next_day = next(temp, None)

    #so next cls is first cls next day
    for key in TT[next_day]:
        print(next_day)
        nextcls["day"]     = next_day
        nextcls["time"]    = key
        nextcls["subject"] = TT[next_day][key]
        return nextcls
    

     






# Main excecution starts

#Update time stuff
Date = datetime.datetime.now()
weekday = Date.strftime("%A") # format eg: Wednesday
hour = Date.strftime("%H")    # 24hour format
minute = Date.strftime("%M")

TT = getData(TIMETABLE_LINK)
right_now = getsubject_or_none(hour, minute, TT)
if( right_now == None):
    nextclass_time = nextclass(hour, minute, TT)
    print(nextclass_time)
else:
    print("hello")
    print(right_now)

    ###########################
    ####    AGENDA         ####
    # complete that else case
    # figure out webdriver auto installer
    # figure out gui
    
